#**链表（下）：如何轻松写出正确的链表代码？**

##**技巧一：理解指针或引用的含义**

*	对指针的理解：将某个变量赋值给指针，实际上就是讲这个变量地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。
*	例如：p->next=q。这行代码是说，p结点的next指针存储了q结点的内存地址。

	p->next=p->next->next。这行代码表示，p结点的next指针存储了p结点的下下一个结点的内存地址。

##**技巧二：警惕指针丢失和内存泄漏**

我们希望在结点a和相邻结点b之间插入结点x，假设当前指针p指向结点a。

```

	p->next = x; // 将 p 的 next 指针指向 x 结点；
	x->next = p->next; // 将 x 的结点的 next 指针指向 b 结点；

```

初学者经常会再这犯错，p->next指针在完成第一步操作后，已经不再指向结点b了，而是指向结点x。第2行代码相当于将x赋值给x->next，自己指向自己。因此，整个链表也就断成了两半，从结点b往后的所有结点都无法访问到了。

对于有些语言来说，比如C语言，内存管理是由程序员负责的，如果没有手动释放结点对应的内存空间，就会产生内存泄漏。所以，我们插入结点时，一定要注意操作的顺序，要先将结点x的next指针指向结点b，再把结点a的next指针指向结点x，这样才不会丢失指针，导致内存泄漏。所以，对于刚刚插入的代码，我们只需要把第1行和第2行代码的顺序颠倒一下就可以了。

同理，删除链表结点时，也一定要记得手动释放内存空间，否则，也会出现内存泄漏的问题。当然，对于想Java这种虚拟机自动管理内存的编程语言来说，就不需要考虑那么多了。

##**技巧三：利用哨兵简化实现难度**

head=NULL 表示链表中没有结点。其中head表示头结点指针，指向链表中的第一个结点。

如果我们引入哨兵结点，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫带头链表。相反，没有哨兵结点的链表就叫作不带头链表。

哨兵结点是不存储数据的。因为哨兵结点一直存在，所以插入第一个结点和插入其他结点，删除最后一个结点和删除其他结点，都可以统一为相同的代码实现逻辑了。

![Markdown](http://i1.fuimg.com/702319/c4796cfa97a54535.jpg)

插入排序、归并排序、动态规划等算法都用到了哨兵简化编程难度的技巧。

##**技巧四：重点留意边界条件处理**

常用来检查链表代码是否正确的边界条件：

*	如果链表为空时，代码是否能正常工作？
*	如果链表只包含一个结点时，代码是否能正常工作？
*	如果链表只包含两个结点时，代码是否能正常工作？
*	代码逻辑在处理头结点和尾结点的时候，代码是否能正常工作？

##**技巧五：举例画图，辅助思考**

##**技巧六：多写多练，没有捷径**

##**5种常见的链表操作**

*	单链表反转
*	链表中环的检测
*	两个有序的链表合并
*	删除链表倒数第n个结点
*	求链表的中间结点